<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>韩小平的博客 | 你应该知道的浏览器缓存知识</title>
    <meta name="description" content="Just A Coder.">
    
    
    <link rel="preload" href="/blog/assets/css/23.styles.cc8c2f9e.css" as="style"><link rel="preload" href="/blog/assets/js/app.1f817541.js" as="script"><link rel="preload" href="/blog/assets/js/1.411138db.js" as="script"><link rel="prefetch" href="/blog/assets/js/12.814f811a.js"><link rel="prefetch" href="/blog/assets/js/2.6d9529a4.js"><link rel="prefetch" href="/blog/assets/js/3.4fdc0d88.js"><link rel="prefetch" href="/blog/assets/js/4.deae28fa.js"><link rel="prefetch" href="/blog/assets/js/5.9fdd6adc.js"><link rel="prefetch" href="/blog/assets/js/6.00a6ab47.js"><link rel="prefetch" href="/blog/assets/js/7.da4f18c9.js"><link rel="prefetch" href="/blog/assets/js/8.913fdfc3.js"><link rel="prefetch" href="/blog/assets/js/9.edf39113.js"><link rel="prefetch" href="/blog/assets/js/10.2f0c9cf4.js"><link rel="prefetch" href="/blog/assets/js/11.615d4175.js"><link rel="prefetch" href="/blog/assets/js/0.cffbc176.js"><link rel="prefetch" href="/blog/assets/js/13.69b37d45.js"><link rel="prefetch" href="/blog/assets/js/14.a0bb1f94.js"><link rel="prefetch" href="/blog/assets/js/15.9690300e.js"><link rel="prefetch" href="/blog/assets/js/16.d94b26bb.js"><link rel="prefetch" href="/blog/assets/js/17.49b0032e.js"><link rel="prefetch" href="/blog/assets/js/18.53f1b6f9.js"><link rel="prefetch" href="/blog/assets/js/19.49c9af97.js"><link rel="prefetch" href="/blog/assets/js/20.d43d8101.js"><link rel="prefetch" href="/blog/assets/js/21.c6d918ad.js"><link rel="prefetch" href="/blog/assets/js/22.3be36221.js">
    <link rel="stylesheet" href="/blog/assets/css/23.styles.cc8c2f9e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/blog/" class="home-link router-link-active"><!----><span class="site-name">
      韩小平的博客
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/posts/" class="nav-link router-link-active">文章</a></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/blog/links/" class="nav-link">友链</a></div><a href="https://github.com/excaliburhan" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/posts/" class="nav-link router-link-active">文章</a></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/blog/links/" class="nav-link">友链</a></div><a href="https://github.com/excaliburhan" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><!----></div><div class="page"><div class="content"><h1 id="你应该知道的浏览器缓存知识"><a href="#你应该知道的浏览器缓存知识" aria-hidden="true" class="header-anchor">#</a> 你应该知道的浏览器缓存知识</h1><h2 id="_0-前言"><a href="#_0-前言" aria-hidden="true" class="header-anchor">#</a> 0. 前言</h2><p>浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。之前被人问起浏览器缓存的知识，感觉自己有点一知半解，所以这次好好整理总结了一下。</p><h2 id="_1-浏览器缓存分类"><a href="#_1-浏览器缓存分类" aria-hidden="true" class="header-anchor">#</a> 1. 浏览器缓存分类</h2><p>目前主流的浏览器缓存分为两类，强缓存和协商缓存，它们的匹配流程如下：</p><p>（1）浏览器发送请求前，根据请求头的expires和cache-control判断是否命中强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</p><p>（2）没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</p><p>（3）如果前两步都没有命中，则直接从服务端获取资源。</p><h2 id="_2-强缓存"><a href="#_2-强缓存" aria-hidden="true" class="header-anchor">#</a> 2. 强缓存</h2><h3 id="_2-1-强缓存原理"><a href="#_2-1-强缓存原理" aria-hidden="true" class="header-anchor">#</a> 2.1 强缓存原理</h3><p>强缓存需要服务端设置expires和cache-control。</p><p>nginx代码参考，设置了一年的缓存时间：</p><pre class="language-nginx"><code><span class="token keyword">location</span> <span class="token operator">~</span> <span class="token punctuation">.</span><span class="token operator">*</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>ico<span class="token operator">|</span>svg<span class="token operator">|</span>ttf<span class="token operator">|</span>eot<span class="token operator">|</span>woff<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">proxy_cache</span>               pnc<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_valid</span>         <span class="token number">200</span> <span class="token number">304</span> <span class="token number">1</span>y<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_valid</span>         any <span class="token number">1</span>m<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_lock</span>          on<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_lock_timeout</span>  <span class="token number">5</span>s<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_use_stale</span>     updating error <span class="token keyword">timeout</span> invalid_header http_500 http_502<span class="token punctuation">;</span>
  <span class="token keyword">expires</span>                   <span class="token number">1</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><img src="https://static.excaliburhan.com/blog/20170327/UQQrhatzWnpiKcjkBAR-Cwy5.jpeg" alt="alt"></p><p>（1）expires：从图可以看出，expires的值是一个绝对时间，是http1.0的功能。如果浏览器的时间没有超过这个expires的时间，代表缓存还有效，命中强缓存，直接从缓存读取资源。不过由于存在浏览器和服务端时间可能出现较大误差，所以在之后http1.1提出了cache-control。</p><p>（2）cache-control：从图可以看出，cache-control的值是类似于<code>max-age=31536000</code>这样的，是一个相对时间，31536000是秒数，正好是一年的时间。当浏览器第一次请求资源的时候，会把response header的内容缓存下来。之后的请求会先从缓存检查该response header，通过第一次请求的date和cache-control计算出缓存有效时间。如果浏览器的时间没有超过这个缓存有效的时间，代表缓存还有效，命中强缓存，直接从缓存读取资源。</p><p>两者可以同时设置，但是优先级cache-control &gt; expires。</p><h3 id="_2-2-from-disk-cache和from-memory-cache"><a href="#_2-2-from-disk-cache和from-memory-cache" aria-hidden="true" class="header-anchor">#</a> 2.2 from disk cache和from memory cache</h3><p>Chrome在高版本更新了缓存策略（具体哪个我忘了），原来的<code>from cache</code>变成了<code>from disk cache(磁盘缓存)</code>和<code>from memory cache(内存缓存)</code>两类，两者有什么区别呢？</p><p>先从官方文档来看下：</p><blockquote><p>Chrome employs two caches — an on-disk cache and a very fast in-memory cache. The lifetime of an in-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab. Requests that are answered from the in-memory cache are invisible to the web request API. If a request handler changes its behavior (for example, the behavior according to which requests are blocked), a simple page refresh might not respect this changed behavior. To make sure the behavior change goes through, call handlerBehaviorChanged() to flush the in-memory cache. But don't do it often; flushing the cache is a very expensive operation. You don't need to call handlerBehaviorChanged() after registering or unregistering an event listener.</p></blockquote><p>我的渣六级英语翻一下，大概就是内存缓存是和渲染进程绑定的，大部分情况下于浏览器Tab对应。为此我实验了一下：</p><p>首次打开Tab：</p><p><img src="https://static.excaliburhan.com/blog/20170327/wHYczt-esCaoSWimZ6JHWVhz.jpeg" alt="alt"></p><p>刷新(cmd+r)Tab：</p><p><img src="https://static.excaliburhan.com/blog/20170327/BnoONl2XIQoNYvHCbK7O5-fW.jpeg" alt="alt"></p><p>可以看到，在命中强缓存的情况下，进程初次渲染会从磁盘读取缓存资源。Chrome会将部分资源保存到内存中（具体保存的逻辑还不清楚，如果有知道的请告知）。</p><p>由于内存缓存是直接从内存中读取的，所以速度更快，从图中可以看出时间是0ms。而磁盘缓存还需要从磁盘中读取，速度还和磁盘的I/O有关，时间大概在2～10ms，也是相当快的了。</p><h3 id="_2-3-强缓存作用"><a href="#_2-3-强缓存作用" aria-hidden="true" class="header-anchor">#</a> 2.3 强缓存作用</h3><p>强缓存作为性能优化中缓存方面最有效的手段，能够极大的提升性能。由于强缓存不会向服务端发送请求，对服务端的压力也是大大减小。</p><p>对于不太经常变更的资源，可以设置一个超长时间的缓存时间，比如一年。浏览器在首次加载后，都会从缓存中读取。</p><p>但是由于不会向服务端发送请求，那么如果资源有更改的时候，怎么让浏览器知道呢？现在常用的解决方法是加一个<code>?v=xxx</code>的后缀，在更新静态资源版本的时候，更新这个v的值，这样相当于向服务端发起一个新的请求，从而达到更新静态资源的目的。</p><h2 id="_3-协商缓存"><a href="#_3-协商缓存" aria-hidden="true" class="header-anchor">#</a> 3. 协商缓存</h2><h3 id="_3-1-协商缓存原理"><a href="#_3-1-协商缓存原理" aria-hidden="true" class="header-anchor">#</a> 3.1 协商缓存原理</h3><p>在强缓存没有命中的时候，就是协商缓存发挥的地盘了。协商缓存会根据[last-modified/if-modified-since]或者[etag/if-none-match]来进行判断缓存是否过期。</p><p>nginx代码参考：</p><pre class="language-nginx"><code><span class="token keyword">location</span> <span class="token operator">~</span> <span class="token punctuation">.</span><span class="token operator">*</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>ico<span class="token operator">|</span>svg<span class="token operator">|</span>ttf<span class="token operator">|</span>eot<span class="token operator">|</span>woff<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">proxy_cache</span>               pnc<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_valid</span>         <span class="token number">200</span> <span class="token number">304</span> <span class="token number">1</span>y<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_valid</span>         any <span class="token number">1</span>m<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_lock</span>          on<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_lock_timeout</span>  <span class="token number">5</span>s<span class="token punctuation">;</span>
  <span class="token keyword">proxy_cache_use_stale</span>     updating error <span class="token keyword">timeout</span> invalid_header http_500 http_502<span class="token punctuation">;</span>
  etag                                       on<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><img src="https://static.excaliburhan.com/blog/20170327/CrDzh0AaGQw0SJNw714JjHRC.jpeg" alt="alt"></p><p>（1）last-modified/if-modified-since:
浏览器首先发送一个请求，让服务端在response header中返回请求的资源上次更新时间，就是<code>last-modified</code>，浏览器会缓存下这个时间。然后浏览器再下次请求中，request header中带上<code>if-modified-since:[保存的last-modified的值]</code>。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况：一是保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；二是各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。</p><p>（2）etag/if-none-match：</p><blockquote><p>etag是http协议提供的若干机制中的一种Web缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。
和<code>last-modified</code>一样，浏览器会先发送一个请求得到etag的值，然后再下一次请求在request header中带上<code>if-none-match:[保存的etag的值]</code>。通过发送的etag的值和服务端重新生成的etag的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。</p></blockquote><p>etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。</p><h3 id="_3-2-协商缓存作用"><a href="#_3-2-协商缓存作用" aria-hidden="true" class="header-anchor">#</a> 3.2 协商缓存作用</h3><p>协商缓存是无法减少请求数的开销的，但是可以减少返回的正文大小。一般来说，对于勤改动的html文件，使用协商缓存是一种不错的选择。</p><h2 id="_4-刷新缓存方法"><a href="#_4-刷新缓存方法" aria-hidden="true" class="header-anchor">#</a> 4. 刷新缓存方法</h2><p>刷新强缓存可以使用<code>?v=xxx</code>的后缀。当然，人工更改版本号的成本比较高，而且难以维护，现在主流的是通过webpack等打包工具生成<code>[name].[hash].js</code>之类的文件名，也能刷新强缓存。</p><p>刷新协商缓存比较简单，修改文件内容即可。</p><p>对于浏览器而言，在Chrome中，你可以使用<code>审查元素</code>，高版本也叫<code>检查</code>，将Network中的Disable cache打勾，使用<code>cmd+r</code>刷新页面即可。当然你也可以使用强制刷新，直接在页面使用<code>cmd+shift+r</code>进行刷新。</p><h2 id="_5-结尾"><a href="#_5-结尾" aria-hidden="true" class="header-anchor">#</a> 5. 结尾</h2><p>以上就是对浏览器缓存的一点拙见，欢迎一起交流。</p><p>这篇主要交代了浏览器缓存，下一篇文章内容已经想好了，就是html5的离线缓存。</p></div><!----><!----></div></div></div>
    <script src="/blog/assets/js/1.411138db.js" defer></script><script src="/blog/assets/js/app.1f817541.js" defer></script>
  </body>
</html>
